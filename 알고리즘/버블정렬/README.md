## 🫧 버블 정렬(Bubble Sort)?

버블 정렬(Bubble Sort)은 이름처럼 물속 거품이 뽀글뽀글 올라오듯이, **가장 큰(또는 가장 작은) 요소가 배열의 한쪽 끝으로 계속 이동하면서 정렬되는 방식** 옆에 있는 친구랑 내 키 비교해서 자리 바꾸는 거랑 비슷한 원리

**핵심**: 인접한 두 요소를 비교해서 기준에 맞지 않으면 자리를 바꾸는 과정을 계속 반복

---

## 🏃‍♀️ 버블 정렬, 작동 원리

배열의 첫 번째 요소부터 시작해서 바로 옆에 있는 요소랑 비교, 만약 순서가 맞지 않으면(`오름차순`이라면 왼쪽이 더 크면) 서로 자리를 바꿈 이 과정을 배열의 끝까지 반복하면, 한 번의 "회전"이 끝날 때마다 가장 큰(또는 작은) 값이 배열의 맨 끝으로 이동하게 된다.

이런 "회전"을 전체 배열 크기만큼 반복하면 모든 요소가 정렬됨

**✨ 오름차순 Example**

`[7, 4, 5, 1, 3]` 배열을 오름차순으로 정렬 예시

### 1회전 (가장 큰 값 7이 맨 뒤로)
*   `(7, 4)` 비교 -> 4, 7로 `swap`!  ➡️ `[4, 7, 5, 1, 3]`
*   `(7, 5)` 비교 -> 5, 7로 `swap`!  ➡️ `[4, 5, 7, 1, 3]`
*   `(7, 1)` 비교 -> 1, 7로 `swap`!  ➡️ `[4, 5, 1, 7, 3]`
*   `(7, 3)` 비교 -> 3, 7로 `swap`!  ➡️ `[4, 5, 1, 3, 7]`

💡 이제 7은 자기 자리를 찾았으니 다음 회전부터는 `7`을 제외한 나머지 애들만 비교하면 됨

### 2회전 (그다음 큰 값 5가 제자리로)
*   `(4, 5)` 비교 -> `swap` 안 함 (이미 4 < 5) ➡️ `[4, 5, 1, 3, 7]`
*   `(5, 1)` 비교 -> 1, 5로 `swap`! ➡️ `[4, 1, 5, 3, 7]`
*   `(5, 3)` 비교 -> 3, 5로 `swap`! ➡️ `[4, 1, 3, 5, 7]`

💡 5도 제자리를 찾았으니 이제 7이랑 5 빼고 나머지 애들만 보면 됨

### 3회전 
*   `(4, 1)` 비교 -> 1, 4로 `swap`! ➡️ `[1, 4, 3, 5, 7]`
*   `(4, 3)` 비교 -> 3, 4로 `swap`! ➡️ `[1, 3, 4, 5, 7]`

### 4회전 
*   `(1, 3)` 비교 -> `swap` 안 함 ➡️ `[1, 3, 4, 5, 7]`


---

## 🔍 특징 및 성능

*   **시간 복잡도 (Time Complexity)**
    *   **최선 (Best Case)**: `O(n)` (이미 정렬된 상태라면 한 번 쭉 훑어보고 끝)
    *   **평균 (Average Case)**: `O(n^2)` (가장 흔한 경우)
    *   **최악 (Worst Case)**: `O(n^2)` (완전히 역순으로 정렬된 경우.)
*   **공간 복잡도 (Space Complexity)**: `O(1)` (별도의 추가 공간 없이 제자리에서 정렬하는 `In-place Sort`)

---

## 💻 Java로 구현

```java
import java.util.Arrays; // 배열 출력을 위해 Arrays 클래스 임포트

public class BubbleSortExample {

    /**
     * 버블 정렬 알고리즘을 사용하여 배열을 정렬하는 메서드
     *
     * @param arr 정렬할 정수 배열
     */
    public static void bubbleSort(int[] arr) {
        int n = arr.length; // 배열의 길이
        
        // n-1 번의 '회전(pass)'을 반복. 매 회전마다 가장 큰(또는 작은) 값이 뒤로 이동
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false; // 이번 회전에서 요소 교환이 있었는지 체크하는 플래그
            
            // 한 번의 회전 안에서 인접한 요소들을 비교하고 필요하면 교환 (정렬된 부분 제외)
            // j < n - 1 - i : 이미 뒤에 정렬된 i개의 요소는 다시 비교할 필요가 없어서 제외
            for (int j = 0; j < n - 1 - i; j++) {
                // 현재 요소가 다음 요소보다 크면 (오름차순 정렬 기준)
                if (arr[j] > arr[j + 1]) {
                    // 요소들 위치 바꾸기 (swap)
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true; // 교환이 발생했음을 표시
                }
            }
            
            // 이번 회전(pass)에서 한 번도 교환이 없었다면,
            // 배열은 이미 정렬된 상태이므로 더 이상 반복할 필요가 없음
            if (!swapped) {
                System.out.println((i + 1) + "회전에서 정렬 완료 (조기 종료)!");
                break; // 반복문 종료!
            }
            System.out.println((i + 1) + "회전 후 배열 상태: " + Arrays.toString(arr));
        }
    }

    public static void main(String[] args) {
        int[] myList = {7, 4, 5, 1, 3};

        System.out.println("원본 배열: " + Arrays.toString(myList));

        // 버블 정렬 메서드 호출
        bubbleSort(myList);
    }
}
```
