## 🧐 선택 정렬(Selection Sort)?

선택 정렬은 배열 안에서 **가장 작은(또는 가장 큰) 요소를 찾아서 정렬되지 않은 부분의 맨 앞(또는 맨 뒤) 요소와 자리를 바꾸는(Swap) 정렬 방식**. 이 과정을 배열 전체가 정렬될 때까지 반복

**핵심**: 매번 '최소(또는 최대)값'을 찾아서 자기 자리에 '선택'해서 넣어버리는 느낌?

---

## 🏃‍♀️ 선택 정렬, 작동 원리

선택 정렬은 크게 두 단계로 나눌 수 있어:

1.  **최솟값(또는 최댓값) 찾기**: 정렬되지 않은 부분의 배열에서 가장 작은(오름차순 기준) 요소를 찾음
2.  **교환(Swap)**: 찾은 최솟값을 정렬되지 않은 부분의 첫 번째 요소와 자리를 바꿈

이 두 단계를 배열의 모든 요소가 정렬될 때까지 반복. 매 단계가 끝날 때마다 배열의 앞부분은 점점 정렬된 상태로 채워지게 됨

**✨ 예를 들어볼까? (오름차순)**

`[7, 4, 5, 1, 3]` 배열을 오름차순으로 정렬하는 예시

### 1회전 (첫 번째 자리 찾기)
*   **대상**: `[7, 4, 5, 1, 3]`
*   **최솟값 찾기**: `7, 4, 5, 1, 3` 중에서 제일 작은 값은? `1`!
*   **교환**: `1`을 현재 첫 번째 위치인 `7`과 바꿈 ➡️ `[1, 4, 5, 7, 3]`
*   이제 `1`은 정렬 완료

### 2회전 (두 번째 자리 찾기)
*   **대상**: `[1, 4, 5, 7, 3]` (정렬된 `1`은 제외하고, `4, 5, 7, 3` 중에서)
*   **최솟값 찾기**: `4, 5, 7, 3` 중에서 제일 작은 값은? `3`!
*   **교환**: `3`을 현재 정렬되지 않은 부분의 첫 번째 위치인 `4`와 바꿈 ➡️ `[1, 3, 5, 7, 4]`
*   이제 `1, 3`은 정렬 완료

### 3회전 (세 번째 자리 찾기)
*   **대상**: `[1, 3, 5, 7, 4]` (정렬된 `1, 3`은 제외하고, `5, 7, 4` 중에서)
*   **최솟값 찾기**: `5, 7, 4` 중에서 제일 작은 값은? `4`!
*   **교환**: `4`를 현재 정렬되지 않은 부분의 첫 번째 위치인 `5`와 바꿈 ➡️ `[1, 3, 4, 7, 5]`
*   이제 `1, 3, 4`는 정렬 완료

### 4회전 (네 번째 자리 찾기)
*   **대상**: `[1, 3, 4, 7, 5]` (정렬된 `1, 3, 4`는 제외하고, `7, 5` 중에서)
*   **최솟값 찾기**: `7, 5` 중에서 제일 작은 값은? `5`!
*   **교환**: `5`를 현재 정렬되지 않은 부분의 첫 번째 위치인 `7`과 바꿈 ➡️ `[1, 3, 4, 5, 7]`
*   이제 `1, 3, 4, 5`는 정렬 완료


---

## 🔍 특징 및 성능 (이 정도는 알아야 인싸!)

알고리즘에서 성능 얘기는 빼놓을 수 없지!

*   **시간 복잡도 (Time Complexity)**
    *   **최선 (Best Case)**: `O(n^2)` (이미 정렬되어 있어도 다 찾아봐야 함)
    *   **평균 (Average Case)**: `O(n^2)`
    *   **최악 (Worst Case)**: `O(n^2)`
    *   선택 정렬은 어떤 경우든 항상 `O(N^2)`이야. 왜냐면 최솟값(또는 최댓값)을 찾기 위해 항상 모든 요소를 꼼꼼하게 비교해야 함
*   **공간 복잡도 (Space Complexity)**: `O(1)` (별도의 추가 공간 없이 제자리에서 정렬하는 `In-place Sort`)


---

## 💻 Java로 구현해보기 (코드로 보면 더 쉬움)

```java
import java.util.Arrays;

public class SelectionSortExample {

    /**
     * 선택 정렬 알고리즘을 사용하여 배열을 정렬하는 메서드
     *
     * @param arr 정렬할 정수 배열
     */
    public static void selectionSort(int[] arr) {
        int n = arr.length;

        // 배열의 마지막 요소는 자동으로 정렬되므로, n-1번만 순회
        for (int i = 0; i < n - 1; i++) {
            // 정렬되지 않은 부분의 첫 번째 요소를 최솟값의 인덱스로 초기 설정
            int minIndex = i;

            // 정렬되지 않은 나머지 부분에서 최솟값 찾기
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j; // 더 작은 값을 찾으면 인덱스 갱신
                }
            }

            // 찾은 최솟값(minIndex 위치)을 현재 정렬되지 않은 부분의 첫 번째(i 위치)와 교환
            // (만약 minIndex가 i와 같다면 이미 제자리에 있는 것이므로 교환하지 않아도 됨)
            if (minIndex != i) {
                int temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
            System.out.println((i + 1) + "회전 후 배열 상태: " + Arrays.toString(arr));
        }
    }

    public static void main(String[] args) {
        int[] myList = {7, 4, 5, 1, 3};

        System.out.println("원본 배열: " + Arrays.toString(myList));

        // 선택 정렬 메서드 호출
        selectionSort(myList);

        System.out.println("정렬된 배열: " + Arrays.toString(myList));

        System.out.println("\n--- 이미 정렬된 배열 테스트 ---");
        int[] alreadySortedList = {1, 2, 3, 4, 5};
        System.out.println("원본 배열 (이미 정렬됨): " + Arrays.toString(alreadySortedList));
        selectionSort(alreadySortedList);
        System.out.println("정렬된 배열: " + Arrays.toString(alreadySortedList));
    }
}
