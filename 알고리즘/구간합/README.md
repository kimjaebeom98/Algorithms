# 구간합 ❓

**일정 범위의 합**, 예를 들어 크기가 5인 배열 A가 있고 첫 번째부터 세 번째까지의 합을 구하라고 하면 구간 합 S는
S = A[0] + A[1] + A[2]이다.

> 이게 왜 좋냐면 합 배열을 안다면 구간 합을 구하는 건 **O(1)** 의 시간복잡도를 가지기 때문이다.

## 합 배열 S의 정의

> S[i] = A[0] + A[1] + A[2] + ... + A[i-1] + A[i] // A[0]부터 A[i]까지의 합

| 인덱스   | 0   | 1   | 2   | 3   |
| -------- | --- | --- | --- | --- |
| 배열 A   | 15  | 13  | 10  | 7   |
| 구간합 S | 15  | 28  | 38  | 45  |

## 합 배열 S를 만드는 공식

> S[i] = S[i-1] + A[i]

## 구간 합을 구하는 공식

> S[j] - S[i-1] // i에서 j까지의 합

예시: 크기가 6인 배열 A가 주어졌을 때 A[2]부터 A[5]까지의 구간 합을 구하시오.<br>

| 인덱스   | 0   | 1   | 2   | 3   | 4   | 5   |
| -------- | --- | --- | --- | --- | --- | --- |
| 배열 A   | 15  | 13  | 10  | 7   | 3   | 12  |
| 구간합 S | 15  | 28  | 38  | 45  | 48  | 60  |

S[5] - S[1] = 60 - 28 = 32

```java
int[] A = {15, 13, 10, 7, 3, 12};
int[] S = new int[6];
S[0] = A[0];

for(int i=1; i<6; i++)
    S[i] = S[i-1] + A[i];

// j = 5, i = 2
System.out.println(S[5] - S[1]);
```

## 2차원 구간합

2차원 구간합은 마크다운으로 정리하는데에 있어서 큰 어려움이 있지만,, 정리 해 보겠음

| 인덱스 | 1   | 2   | 3   | 4   |
| ------ | --- | --- | --- | --- |
| 1      | 1   | 2   | 3   | 4   |
| 2      | 2   | 3   | 4   | 5   |
| 3      | 3   | 4   | 5   | 6   |
| 4      | 4   | 5   | 6   | 7   |

위와 같은 배열 A가 주어졌을 때, 2행 2열부터 3행 4열까지의 합은 ? = 3 + 4 + 5 + 4 + 5 + 6 = 27

> 합 배열을 이용하라고 했는데, 먼저 합 배열은 어떻게 구할까?

먼저 작게 보자면

| 인덱스 | 1   | 2   |
| ------ | --- | --- |
| 1      | 1   | 2   |
| 2      | 2   | 3   |

- 가로 행의 합 배열 S는 = 1 + 2 = 3 = S[i][j-1] + A[i][j]
- 세로 열의 합 배열 S는 = 1 + 2 = 3 = S[i-1][j] + A[i][j]
- 그러면 2행 2열의 합 배열 S는 = 가로 행의 합 배열 S값 + 세로 열의 합 배열 S값 - 중복되는 1행 1열 값 + A[i][j]
- **S[i][j-1] + S[i-1][j] - A[i-1][j-1] + A[i][j]**

> 이 부분을 이해했으면 구간 합을 구하는 방법도 같은 원리니 쉽다.

| 인덱스 | 1   | 2     | 3     | 4     |
| ------ | --- | ----- | ----- | ----- |
| 1      | 1   | 2     | 3     | 4     |
| 2      | 2   | **3** | **4** | **5** |
| 3      | 3   | **4** | **5** | **6** |
| 4      | 4   | 5     | 6     | 7     |

우리가 원하는 부분은 2(x1)행2(y1)열과 3(x2)행4(y2)열 사이의 값들의 합이다 어떻게 구할까?

- 먼저 합 배열 S[3][4]에서 **무엇인가**를 빼면 된다.
- 합 배열 구할 때와 비슷한 원리로 S[3][1]과 S[1][4]을 빼주면 되지 않을까?
- 근데 S[3][1]과 S[1][4] 사이에 S[1][1]이 중첩되므로 하나 더 해주면 된다 !!!
- 최종 공식 : S[x2][y2] - S[x2][y1-1] - S[x1-1][y2] + S[x1-1][y1-1]
