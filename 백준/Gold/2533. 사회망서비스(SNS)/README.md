# 사회망서비스(SNS) - 2533 

[문제 링크](https://www.acmicpc.net/problem/2533) 

### 분류

트리에서의 다이나믹 프로그래밍

### 문제 설명

페이스북, 트위터, 카카오톡과 같은 사회망 서비스(SNS)가 널리 사용됨에 따라, 사회망을 통하여 사람들이 어떻게 새로운 아이디어를 받아들이게 되는가를 이해하는 문제가 중요해졌다. 사회망에서 사람들의 친구 관계는 그래프로 표현할 수 있는데,  이 그래프에서 사람은 정점으로 표현되고, 두 정점을 잇는 에지는 두 정점으로 표현되는 두 사람이 서로 친구 관계임을 표현한다. 

예를 들어, 철수와 영희, 철수와 만수, 영희와 순희가 서로 친구 관계라면 이를 표현하는 친구 관계 그래프는 다음과 같다. 

![image](https://user-images.githubusercontent.com/87630540/195271177-41036600-9988-4844-af18-aa538de31565.png)


친구 관계 그래프를 이용하면 사회망 서비스에서 어떤 새로운 아이디어가 전파되는 과정을 이해하는데 도움을 줄 수 있다. 어떤 새로운 아이디어를 먼저 받아들인 사람을 얼리 아답터(early adaptor)라고 하는데, 사회망 서비스에 속한 사람들은 얼리 아답터이거나 얼리 아답터가 아니다. 얼리 아답터가 아닌 사람들은 자신의 모든 친구들이 얼리 아답터일 때만 이 아이디어를 받아들인다. 

어떤 아이디어를 사회망 서비스에서 퍼뜨리고자 할 때, 가능한 한 최소의 수의 얼리 아답터를 확보하여 모든 사람이 이 아이디어를 받아들이게 하는  문제는 매우 중요하다. 

일반적인 그래프에서 이 문제를 푸는 것이 매우 어렵다는 것이 알려져 있기 때문에, 친구 관계 그래프가 트리인 경우, 즉 모든 두 정점 사이에 이들을 잇는 경로가 존재하면서 사이클이 존재하지 않는 경우만 고려한다. 

예를 들어, 8명의 사람으로 이루어진 다음 친구 관계 트리를 생각해보자. 2, 3, 4번 노드가 표현하는 사람들이 얼리 아답터라면, 얼리 아답터가 아닌 사람들은 자신의 모든 친구가 얼리 아답터이기 때문에 새로운 아이디어를 받아들인다.

![image](https://user-images.githubusercontent.com/87630540/195271219-c8a3b4b4-1248-4583-a4bd-827967d1815a.png)


친구 관계 트리가 주어졌을 때, 모든 개인이 새로운 아이디어를 수용하기 위하여 필요한 최소 얼리 어답터의 수를 구하는 프로그램을 작성하시오.

### 입력 

첫 번째 줄에는 친구 관계 트리의 정점 개수 N이 주어진다. 단, 2 ≤ N ≤ 1,000,000이며, 각 정점은 1부터 N까지 일련번호로 표현된다. 두 번째 줄부터 N-1개의 줄에는 각 줄마다 친구 관계 트리의 에지 (u, v)를 나타내는 두 정수 u와 v가 하나의 빈칸을 사이에 두고 주어진다. 

### 출력 

주어진 친구 관계 그래프에서 아이디어를 전파하는데 필요한 얼리 아답터의 최소 수를 하나의 정수로 출력한다.

<hr>
<br>

## 풀이 🚀
와.. 트리에 DP를 적용하는 건 처음이다...근데 가끔 출제되는 유형이라고 한다.. 이번 기회로 알아가야겠다..

### 트리에서의 DP?

- DP의 경우 부문제의 최적해가 모여 전체 문제의 최적해가 찾을 수 있는 경우에 사용할 수 있다.
- 트리 구조의 경우 서브 트리들이 모여 전체 트리를 이루기 때문에 서브 트리의 최적해들을 통해 전체 트리의 최적해를 찾을 수 있다면 트리 구조에도 DP를 사용할 수 있다.
- 서브 트리들의 경우 구분할 수 있는 가장 좋은 포인트는 해당 서브트리의 ROOT 노드다.
- 따라서 구분되는 서브트리들의 ROOT 노드를 통해 DP 배열을 구성할 수 있다.
- 예를 들어 DP[ROOT노드 번호][A][B] ... 이런 식으로 문제 타입에 맞게 A,B... 를 세팅할 수 있다.
- 대부분의 Tree DP는 DFS를 통해 리프 노드까지 나아가고 리프 노드 부터 부문제를 해결하면서 위쪽으로 차근차근 올라온다.
- 즉 리프 노드쪽 부터 부문제를 해결해보면 마지막에는 최종 본 트리의 ROOT 노드의 본 문제를 해결할 것이고 앞에서 구한 것들을 통해 최적해를 구할 수 있을 것이다.

### 구현 🏃‍♂️

먼저 DP를 어케 설계하느냐..
- **DP[i][1]는 현재 i 노드가 얼리어 답터일 때,**
- 자식 노드들은 얼리어 답터가 되든 말든 상관없이 자식 노드들의 최적해를 더 해주면된다 
- DP[parent][1] += min(DP[child][0], DP[child][1])
- **DP[i][0]은 현재 i 노드가 얼리어 답터가 아닐 때,**
- i의 자식 노드 모두 얼리어 답터여야 한다!!
- DP[parent][0] += DP[child][1]
- 사이클이 없는 트리의 특성상 root 노드는 아무나 정해도 상관없다, 그러나 단방향 그래프가 아닌 양방향 그래프로 하여 서로 서로 이동 가능하게 끔 설계해줘야 함

### 코드 📃

```python

import sys
sys.setrecursionlimit(10**8)

input = sys.stdin.readline


n = int(input())
graph = [[] for _ in range(n+1)]
for i in range(n-1):
    u, v = map(int, input().split())
    graph[u].append(v)
    graph[v].append(u)

visited = [0] * (n+1)
# dp[i][0]는 i 노드가 얼리어 답터가 아닐 때
# dp[i][1]은 i 노드가 얼리어 답터일 때
dp = [[0, 0] for _ in range(n+1)]


def dfs(parent):
   # 내가 얼리어답터니깐 일단 + 1
    dp[parent][1] = 1
    visited[parent] = 1
    for child in graph[parent]:
        if not visited[child]:
            dfs(child)
            # 내가 얼리어답터가 아닐 때는 자식 노드들이 모두 얼리어답터여야함
            dp[parent][0] += dp[child][1]
            # 내가 얼리어답터일 때는 자식 노드들이
            # 얼리어답터인지 아닌지 상관없이 둘 중 최솟값을 더해줌
            dp[parent][1] += min(dp[child][0], dp[child][1])


dfs(1)
print(min(dp[1][0], dp[1][1]))

```
